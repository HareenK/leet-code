static auto _ = [] () {ios_base::sync_with_stdio(false);cin.tie(nullptr); cout.tie(nullptr);return 0;}();

class Solution {
public:
    
    unordered_set<string> result;
    int ssize;
    int leftUsed;
    int rightUsed;
    int len; 
    string s;
    
    void dfs (string & curr, int index, int left, int right, int used) {
        
       // cout << "s - " << s << " curr - " << curr << " index - " << index << " left - " << left << " right - " << right << endl;
        // cout << "r - " << curr << endl;
        
        if (index == ssize && left == leftUsed && right == rightUsed) {
            result.insert(curr);
            return;
        }
        
        if (index == ssize) {
            return;
        }
        
        if (used > len) {
            return;
        }        
        
        char c = s[index];
        
        if (c == '(') {
            // Don't use this char.
            dfs (curr, index+1, left, right, used);
            // Use this char.
            curr = curr + c;
            dfs (curr, index+1, left+1, right, used+1);
            curr.pop_back();
        } else if (c == ')') {
            if (left > right) {
                // If we can spare a few close brackets -- 
                // two options - 
                // 1) Don't use it.
                // 2) Use it.
                dfs (curr, index+1, left, right, used);
                curr = curr + c;
                dfs (curr, index+1, left, right+1, used+1);
                curr.pop_back();
            } else {
                // If the count of the rights are as many as lefts ... 
                // don't use the current closing bracket.
                dfs (curr, index+1, left, right, used);
            }
        } else {
            // If the curr char isn't '(' or ')' just increase index further. 
            curr = curr + c;
            dfs (curr, index+1, left, right, used+1);
            curr.pop_back();
            
        }
        return; 
    }
    
    vector<string> removeInvalidParentheses(string S) {
        // Can I do it as the other valid parantheses problem. 
        // use a mix of backtracking and see if we can get a valid parantheses order. 
        
        // () )) ((()()) ( 
        // left = 6
        // right = 4
        s = S;
        ssize = s.size();
        
        int l = 0, r = 0;
        
        int extra = 0;
        
		for(int i=0; i< s.size();i++)
		{
			if(s[i]=='(') l++;
			if(s[i]==')') r++;
			if(r>l) 
			{
				r--;
			}
            if (s[i] != '(' && s[i] != ')')
                extra++;
		}

		leftUsed = rightUsed = r;
    
        len = leftUsed + rightUsed + extra;
        
        // cout << "left - " << l << " right - " << r << " extra - " << extra << endl;
        
        string curr = ""; 
        
        dfs (curr, 0, 0, 0, 0);
        
        return vector<string>(result.begin(), result.end());
        
    }
};


// string validateString (string s, char open, char close) {
    
//     string result = "";
//     int balance = 0;
    
//     for (auto & c : s) {
//         if (c == open)
//             balance++;
//         if (c == close) {
//             if (balance == 0) {
//                 continue;
//             } else {
//                 balance--;
//             }
//         }   
//         result += c;   
//     }
//     return result;
// }

// class Solution {
// public:

// 	vector<string> ans;
// 	bool check(string& s)
// 	{
// 		int l=0, r=0;
// 		for(int i=0;i<s.size();i++)
// 		{
// 			if(s[i]=='(') l++;
// 			if(s[i]==')') r++;
// 			if(r>l) return false;
// 		}

// 		return l==r;

// 	}


// 	void dfs(string& s,string cur,int idx, int left, int right )
// 	{
        
// 		if(left==0 && right==0 && idx==s.size())
// 		{
//             cout << "curr - " << curr << endl; 
// 			if(check(cur))
// 			{
// 				ans.push_back(cur);
// 			}

// 			return;
// 		}

// 		if(idx>=s.size())
// 		{
// 			return;
// 		}

// 		if(right>0)
// 		{
// 			if(s[idx]==')')
// 			{
// 				dfs(s,cur,idx+1,left,right-1);
// 				dfs(s,cur+s[idx],idx+1,left,right);
// 			}
// 			else
// 			{
// 				dfs(s,cur+s[idx],idx+1,left,right);
// 			}
// 		}

// 		else
// 		{
// 			if(s[idx]=='(')
// 			{
// 				dfs(s,cur,idx+1,left-1,right);
// 				dfs(s,cur+s[idx],idx+1,left,right);
// 			}
// 			else
// 			{
// 				dfs(s,cur+s[idx],idx+1,left,right);
// 			}
// 		}

// 	   // }


// 	}

// 	vector<string> removeInvalidParentheses(string s) {
// 		int left=0 , right=0, l=0, r=0;
// 		for(int i=0;i<s.size();i++)
// 		{
// 			if(s[i]=='(') l++;
// 			if(s[i]==')') r++;
// 			if(r>l) 
// 			{
// 				right++;
// 				r--;
// 			}
// 		}

// 		left=l-r;
// 		string cur="";
// 		dfs(s,cur,0,left,right);

// 		unordered_set<string> a(ans.begin(),ans.end());
// 		vector<string> res(a.begin(),a.end());
// 		return res;


// 	}
// };
