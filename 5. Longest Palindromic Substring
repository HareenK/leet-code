5. Longest Palindromic Substring

Given a string s, return the longest palindromic substring in s.

Example 1:

Input: s = "babad"
Output: "bab"
Note: "aba" is also a valid answer.

Example 2:

Input: s = "cbbd"
Output: "bb"

Example 3:

Input: s = "a"
Output: "a"

Example 4:

Input: s = "ac"
Output: "a"

Constraints:

    1 <= s.length <= 1000
    s consist of only digits and English letters (lower-case and/or upper-case),

// class Solution {
// public:
//     int expandAroundCenter(const string & s, int i, int j) {
//         int left = i;
//         int right = j; 
        
//         while (left >= 0 && right < s.size() && s[left] == s[right]) {
//             left--; right++;
//         }
//         return right - left - 1;
//     }
    
//     string longestPalindrome(string s) {
        
//         int size = s.size();
        
//         if (size == 0 || size == 1) return s;
        
        
//         int len1 = 0;
//         int len2 = 0;
        
//         int start = 0;
//         int end = 0;
        
//         int len = 0;
        
//         for (int  i = 0; i < size; i++) {
//             // Consider an odd palindrome centered at i, and 
//             // an even-length palindrome centered around [i,i+1]
//             len1 = expandAroundCenter(s,i,i);
//             len2 = expandAroundCenter(s,i,i+1);
            
//             cout << "i - " << i << " len1 - " << len1 << endl;
            
//             len = max(len1, len2);
            
//             if (len > end - start + 1) {
//                 start = i - (len - 1)/2;
//                 end = i +  len/2;
//             }
//         }             
//         return s.substr(start, end-start+1);
//     }
// };


class Solution {
    public: 
    string longestPalindrome (string s) {
        int size = s.size();
        
        if (!size)
            return "";
        
        int l = 0, r = 0;
        
        for (int i = 0; i < 2*size-1; i++) {
            int left = i/2;
            int right =  (i+1)/2;
            while (left >= 0 && right < size && s[left] == s[right]) {
                left--; right++;
            }
            // right- 1 - left + 1 +1
            if (right-left-1 > r-l-1) {
                l = left; r = right;
            }
        }
        // cout << l  << " " << r << endl;  
        return s.substr(l+1, r-l-1); // 3-1 ... (r-1) - (l+1) + 1 ..
    }
};
